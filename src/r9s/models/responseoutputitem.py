"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from pydantic import model_serializer
from r9s.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
from typing import Any, List, Literal, Optional, Union
from typing_extensions import NotRequired, TypeAliasType, TypedDict


ResponseOutputItemType = Literal[
    "message",
    "function_call",
    "reasoning",
]
r"""Output type (message for final response, function_call for tool calls, reasoning for reasoning trace)"""


ResponseOutputItemStatus = Literal[
    "completed",
    "in_progress",
    "incomplete",
]
r"""Output status"""


ResponseOutputItemRole = Literal[
    "user",
    "assistant",
]
r"""Message role"""


ResponseOutputItemSchemasType = Literal[
    "text",
    "refusal",
    "output_text",
    "reasoning_text",
]
r"""Content type (text for messages, output_text for responses, reasoning_text for reasoning traces, refusal for safety refusals)"""


class ResponseOutputItemContentTypedDict(TypedDict):
    type: NotRequired[ResponseOutputItemSchemasType]
    r"""Content type (text for messages, output_text for responses, reasoning_text for reasoning traces, refusal for safety refusals)"""
    text: NotRequired[str]
    r"""Text content"""
    refusal: NotRequired[str]
    r"""Refusal content"""
    annotations: NotRequired[List[Any]]
    r"""Content annotations"""
    logprobs: NotRequired[List[Any]]
    r"""Log probabilities"""


class ResponseOutputItemContent(BaseModel):
    type: Optional[ResponseOutputItemSchemasType] = None
    r"""Content type (text for messages, output_text for responses, reasoning_text for reasoning traces, refusal for safety refusals)"""

    text: Optional[str] = None
    r"""Text content"""

    refusal: Optional[str] = None
    r"""Refusal content"""

    annotations: Optional[List[Any]] = None
    r"""Content annotations"""

    logprobs: Optional[List[Any]] = None
    r"""Log probabilities"""


SummaryTypedDict = TypeAliasType("SummaryTypedDict", Union[str, List[Any]])
r"""Natural-language summary of reasoning (for reasoning type), can be string or array"""


Summary = TypeAliasType("Summary", Union[str, List[Any]])
r"""Natural-language summary of reasoning (for reasoning type), can be string or array"""


class ResponseOutputItemTypedDict(TypedDict):
    id: str
    r"""Unique identifier for output item"""
    type: ResponseOutputItemType
    r"""Output type (message for final response, function_call for tool calls, reasoning for reasoning trace)"""
    status: NotRequired[ResponseOutputItemStatus]
    r"""Output status"""
    role: NotRequired[ResponseOutputItemRole]
    r"""Message role"""
    content: NotRequired[List[ResponseOutputItemContentTypedDict]]
    r"""Content array"""
    call_id: NotRequired[str]
    r"""Function call ID"""
    name: NotRequired[str]
    r"""Function name"""
    arguments: NotRequired[str]
    r"""Function arguments (JSON string)"""
    output: NotRequired[str]
    r"""Function output"""
    summary: NotRequired[Nullable[SummaryTypedDict]]
    r"""Natural-language summary of reasoning (for reasoning type), can be string or array"""
    encrypted_content: NotRequired[Nullable[str]]
    r"""Encrypted reasoning tokens for stateless workflows (for reasoning type)"""


class ResponseOutputItem(BaseModel):
    id: str
    r"""Unique identifier for output item"""

    type: ResponseOutputItemType
    r"""Output type (message for final response, function_call for tool calls, reasoning for reasoning trace)"""

    status: Optional[ResponseOutputItemStatus] = None
    r"""Output status"""

    role: Optional[ResponseOutputItemRole] = None
    r"""Message role"""

    content: Optional[List[ResponseOutputItemContent]] = None
    r"""Content array"""

    call_id: Optional[str] = None
    r"""Function call ID"""

    name: Optional[str] = None
    r"""Function name"""

    arguments: Optional[str] = None
    r"""Function arguments (JSON string)"""

    output: Optional[str] = None
    r"""Function output"""

    summary: OptionalNullable[Summary] = UNSET
    r"""Natural-language summary of reasoning (for reasoning type), can be string or array"""

    encrypted_content: OptionalNullable[str] = UNSET
    r"""Encrypted reasoning tokens for stateless workflows (for reasoning type)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "status",
            "role",
            "content",
            "call_id",
            "name",
            "arguments",
            "output",
            "summary",
            "encrypted_content",
        ]
        nullable_fields = ["summary", "encrypted_content"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
